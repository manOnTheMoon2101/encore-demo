/// <reference types="node" />
import * as runtime from "../../internal/runtime/mod.js";
import { StringLiteral } from "../../internal/utils/constraints.js";
export interface SQLMigrationsConfig {
    path: string;
    source?: "prisma" | "drizzle";
}
export interface SQLDatabaseConfig {
    migrations?: string | SQLMigrationsConfig;
}
/**
 * Represents a single row from a query result
 */
export type Row = Record<string, any>;
/** Represents a type that can be used in query template literals */
export type Primitive = string | number | boolean | Buffer | Date | null;
/**
 * Constructing a new database object will result in Encore provisioning a database with
 * that name and returning this object to represent it.
 *
 * If you want to reference an existing database, use `Database.Named(name)` as it is a
 * compile error to create duplicate databases.
 */
export declare class SQLDatabase {
    private readonly impl;
    /**
     * Creates a new database with the given name and configuration
     */
    constructor(name: string, cfg?: SQLDatabaseConfig);
    /**
     * Reference an existing database by name, if the database doesn't
     * exist yet, use `new Database(name)` instead.
     */
    static named<name extends string>(name: StringLiteral<name>): SQLDatabase;
    /**
     * Returns the connection string for the database
     */
    get connectionString(): string;
    /**
     * query queries the database using a template string, replacing your placeholders in the template
     * with parametrised values without risking SQL injections.
     *
     * It returns an async generator, that allows iterating over the results
     * in a streaming fashion using `for await`.
     *
     * @example
     *
     * const email = "foo@example.com";
     * const result = database.query`SELECT id FROM users WHERE email=${email}`
     *
     * This produces the query: "SELECT id FROM users WHERE email=$1".
     */
    query<T extends Row = Record<string, any>>(strings: TemplateStringsArray, ...params: Primitive[]): AsyncGenerator<T>;
    /**
     * queryRow is like query but returns only a single row.
     * If the query selects no rows it returns null.
     * Otherwise it returns the first row and discards the rest.
     *
     * @example
     * const email = "foo@example.com";
     * const result = database.queryRow`SELECT id FROM users WHERE email=${email}`
     */
    queryRow<T extends Row = Record<string, any>>(strings: TemplateStringsArray, ...params: Primitive[]): Promise<T | null>;
    /**
     * exec executes a query without returning any rows.
     *
     * @example
     * const email = "foo@example.com";
     * const result = database.exec`DELETE FROM users WHERE email=${email}`
     */
    exec(strings: TemplateStringsArray, ...params: Primitive[]): Promise<void>;
    /**
     * Acquires a database connection from the database pool.
     *
     * When the connection is closed or is garbage-collected, it is returned to the pool.
     * @returns a new connection to the database
     */
    acquire(): Promise<Connection>;
}
/**
 * Represents a dedicated connection to a database.
 */
export declare class Connection {
    private readonly impl;
    constructor(impl: runtime.SQLConn);
    /**
     * Returns the connection to the database pool.
     */
    close(): Promise<void>;
    /**
     * query queries the database using a template string, replacing your placeholders in the template
     * with parametrised values without risking SQL injections.
     *
     * It returns an async generator, that allows iterating over the results
     * in a streaming fashion using `for await`.
     *
     * @example
     *
     * const email = "foo@example.com";
     * const result = database.query`SELECT id FROM users WHERE email=${email}`
     *
     * This produces the query: "SELECT id FROM users WHERE email=$1".
     */
    query<T extends Row = Record<string, any>>(strings: TemplateStringsArray, ...params: Primitive[]): AsyncGenerator<T>;
    /**
     * queryRow is like query but returns only a single row.
     * If the query selects no rows it returns null.
     * Otherwise it returns the first row and discards the rest.
     *
     * @example
     * const email = "foo@example.com";
     * const result = database.queryRow`SELECT id FROM users WHERE email=${email}`
     */
    queryRow<T extends Row = Record<string, any>>(strings: TemplateStringsArray, ...params: Primitive[]): Promise<T | null>;
    /**
     * exec executes a query without returning any rows.
     *
     * @example
     * const email = "foo@example.com";
     * const result = database.exec`DELETE FROM users WHERE email=${email}`
     */
    exec(strings: TemplateStringsArray, ...params: Primitive[]): Promise<void>;
}
